signature top
  containerized function
  input ❲input filename❳ {infname}      // name, destructured object name(s)
  input ❲output filename❳ {outfname}

signature read
  leaf
  input filename {filename}
  input req {req}
  output char {char}

signature write 
  leaf
  input filename {filename}
  input char {char}
  output request {request}


implementation top
  containerized function
  child read
  child write
  net ⇒₁〔read〕
  net ⇒₂〔write〕
  net ⇒₃〔read〕
  net ⇒₄〔write〕
  connection〔$self〕«input filename» ⇒₁〔read〕«filename»
  connection〔$self〕«output filename» ⇒₂〔write〕«filename»
  connection〔read〕«char» ⇒₃〔write〕«char»
  connection〔write〕«request» ⇒₄〔read〕«req»
  initially λ(infname, outfname)
    send «input filename» infname
    send «output filename» outfname
  finally λ()
  handler λ(message)

implementation read
  leaf
  own filename
  own contents
  own index
  handler λ(message)
    • «filename»
        λjs (message) {
	    me.filename = message.data;
	    me.contents = fs.readFileSync (me.filename, 'utf8');
	    me.cindex = 0;
	}
    • «req»
       [ !λjs {me.eof ()}
         | no: send «char» λjs {me.nextChar ()}
         | *: pass
       ]

implementation write
  leaf
  handler λ(message)
    • «filename»
        send «request» trigger
    • «char» 
        λjs {console.log (me.message.data)}
        send «request» trigger

// ❲❳◦λ⋵
