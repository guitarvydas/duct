dia {
  Main = Implementation+
  Implementation = ContainerImplementation | SynchronousLeafImplementation

ContainerImplementation =
  | "implementation" name "(" NameList ")" SequenceOfBoxes -- withParam
  | "implementation" name SequenceOfBoxes -- noParam

SynchronousLeafImplementation 
  = "sync" name "<=" DatumList Box -- withFormals
  | "sync" name                Box -- withoutFormals

SequenceOfBoxes = NestedBox+
NestedBox = Box
NB = NestedBox
Box = "{" BoxOperation Box? "}"
OrElse = "{" "orelse" Box "}"

BoxOperation
  = ForEvery
  | Synonym
  | FindConnectionFromMe
  | Find
  | Lookup
  | WithLock
  | Cond
  | VarBox
  | WhenAll
  | When
  | Return
  | CheckReturn
  | SynchronousCall
  | Pass

WhenAll = "when" "all" PredicateBlock NestedBox
When = "when" "messages" NB?
Return = "->" DatumList NB?
CheckReturn = "check" "return" string NB?
FindConnectionFromMe = "find" Datum "from" "me" "on" "port" Datum NB?
Pass = "pass"

Cond = "cond" FirstCondClause RestCondClause*
FirstCondClause = CondClause
RestCondClause = CondClause
CondClause = "{" Predicate Box "}"

WithLock = "lock" Datum NB?

Find
  = "find" name "in" Datum "given" ParameterList "=>" name OrElse NB? -- withParams
  | "find" name "in" Datum "=>" name                       OrElse NB? -- withoutParams

VarBox =
  | "var" name "<=" "$i" "{" "{" DatumList "}" Datum "}" NB? -- inputmessage
  | "var" name "<=" "$o" "{" "{" DatumList "}" Datum "}" NB? -- outputmessage
  | "var" name "<="          "{" DatumList "}" NB?           -- array

Synonym =
  | "synonym" name "=" "{" DatumList "}" NB? -- obj
  | "synonym" name "=" Datum NB?             -- solitary

Lookup =
  | "lookup" Datum "=>" name NB?

ForEvery
  = "for" "every" "item" "in" Datum "given" ParameterList "=>" name NB? -- sugaredWithParams
  | "for" "every" name "in" Datum "given" ParameterList "=>" name NB? -- withParams
  | "for" "every" "item" "in" Datum  "=>" name NB? -- sugaredWithoutParams
  | "for" "every" name "in" Datum  "=>" name NB? -- withoutParams


SynchronousCall =
  // no nesting here - Call is a Leaf, not a nested box
  | "@" Datum "<=" Datum -- params
  | "@" Datum            -- noparams
  | "#" Datum "<=" Datum -- external_params
  | "#" Datum            -- external_noparams


Datum
  = Datum "of" Datum -- field
  | Datum "." Datum  -- dottedField
  | kwPORT          -- port
  | kwME            -- me
  | name            -- name

Predicate =
  | Datum "is" "not" "me" -- notme
  | Datum "is" "me"      -- me
  | Datum "==" Datum -- eq
  | Datum "!=" Datum -- ne

PredicateBlock = "{" Predicate PredicateMore* "}"
PredicateMore = Predicate

ParameterList
  = Datum "X" ParameterList -- list
  | Datum                   -- solitary

DatumList 
  = Datum "," DatumList -- list
  | Datum               -- solitary

NameList 
  = name "," NameList -- list
  | name              -- solitary

  separator
    = "<="
    | "=>"
    | "->"
    | "//"
    | "=="
    | "!="
    | "$i"
    | "$o"
    | "="
    | "{"
    | "}"
    | "("
    | ")"
    | "@"
    | "#"
    | "."
    | ","
    | eol

keyword
  = &(~namecharFirst)
          ( "implementation"
          | "messages"
          | "orelse"
          | "return"
          | "given"
          | "lookup"
          | "every"
          | "check"
          | "pass"
          | "lock"
          | "find"
          | "from"
          | "cond"
          | "with"
          | "when"
          | "item"
          | "sync"
          | "port"
          | "for"
          | "all"
          | "not"
          | "is"
          | "in"
          | "on"
          | "of"
          | "me"
          | "X") 
   &(~namecharRest)

kwME = &(~namecharFirst) "me" &(~namecharRest)
kwPORT = &(~namecharFirst) "port" &(~namecharRest)

string = dq (~dq any)* dq
dq = "\""
    
eol = "\n"

name = namecharFirst namecharRest*
namecharFirst = ~separator ~keyword ("_" | "A" .. "Z" | "a" .. "z")
namecharRest = ~separator ~keyword ("_" | "A" .. "Z" | "a" .. "z" | "0" .. "9")

space
 += comment

comment
  = "//" (~"\n" any)* "\n"  -- singleLine
  | "/*" (~"*/" any)* "*/"  -- multiLine

}
